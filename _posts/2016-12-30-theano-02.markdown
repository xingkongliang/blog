---
title: Theano Debugging
layout: post
tags: [Others, Theano]
---

### 1. compute_test_value

> config.compute_test_value

String Value: 'off', 'ignore', 'warn', 'raise'.

Default: 'off'

将属性设置为'off'以外的其他属性会激活调试机制，Theano在构建时，即使执行这个graph on-the-fly。这允许用户在应用优化之前早期发现错误（例如尺寸不匹配）。

Theano将使用有用户提供的常量和/或者共享变量执行这个graph。通过写入它们的'tag.test_value'属性（例如 .tag.test_value = numpy.random.rand(5, 4)），可以用测试值来增强纯符号变量（例如 x = T.dmatrix()）

当不为'off'时，此选项的值指示当Op的输入不提供适当的测试值时发生的情况：

'ignore' 将静默地跳过此操作的调试机制

'warn' 将引发UserWarning并跳过此Op的调试机制

'raise' 将引发异常(Exception)

``` python
>>> from theano import config
>>> config.compute_test_value = 'raise'
>>> x = T.vector()
>>> import numpy as np
>>> x.tag.test_value = np.ones((2,))
>>> y = T.vector()
>>> y.tag.test_value = np.ones((3,))
>>> x + y
...
ValueError: Input dimension mis-match.
(input[0].shape[0] = 2, input[1].shape[0] = 3)
```


### 2. min_informative_str
```python
>>> x = T.scalar()
>>> y = T.scalar()
>>> z = x + y
>>> z.name = 'z'
>>> a = 2. * z
>>> from theano.printing import min_informative_str
>>> print min_informative_str(a)
A. Elemwise{mul,no_inplace}
 B. TensorConstant{2.0}
 C. z
```

### 3. debugprint

```python
>>> from theano.printing import debugprint
>>> debugprint(a)
Elemwise{mul,no_inplace} [id A] ''
 |TensorConstant{2} [id B]
 |Elemwise{add,no_inplace} [id C] 'z'
   |<TensorType(float32, scalar)> [id D]
   |<TensorType(float32, scalar)> [id E]

```

### 4. Print

```python
x = theano.tensor.vector()
x = theano.printing.Print('x', attrs=['min','max'])(x)
```

### 5. Accessing a function's fgraph

```python
>>> x = T.scalar()
>>> y = x / x
>>> f = function([x], y)
>>> debugprint(f.maker.fgraph.outputs[0])
DeepCopyOp [@A] ''
|TensorConstant{1.0} [@B]
```

### 6. WrapLinkers

- 在术语中，链接器是驱动函数的执行的对象。遍历所有Apply节点，并调用输入上的Op的代码以生成输出
- 您可以编写自己的链接器，以使用额外的功能包装每个单独的调用


- 示例使用：
- 通过使用一个Wraplinker保存所有内容，并重新加载它并检查新值是否匹配，来测试该行为是确定性的。
- 如果任何值是NaN，则引发错误


```python
from theano.compile import Mode
def my_callback(i, node, fn):
    # add any preprocessing here
    fn()
    # add any postprocessing here
class MyWrapLinker(Mode):
    def __init__(self):
        wrap_linker = theano.gof.WrapLinkerMany(
            [theano.gof.OpWiseCLinker()],
            [my_callback])
    super(MyWrapLinker, self).__init__(wrap_linker,
            optimizer='fast_run')
my_mode = MyWrapLinker()
f = function(inputs, outputs, mode=my_mode)
```